# -*- coding: utf-8 -*- 
'''
Created on 9th Mar, 2018

@author: Alvin Ye
'''
import dbcCoreModel.CoreModel
import re

class dbcParser(object):
    '''
    classdocs
    '''


    def __init__(self):
        '''
        Constructor
        '''
        self._canNetwork = dbcCoreModel.CoreModel.CanNetwork()
        self.keyWords = {'VERSION':self.versionHdl,
                         'BU_':self.nodeHdl,
                         'BO_':self.msgHdl,
                         ' SG_':self.signalHdl}
        self._currentNode = None
        self._currentMsg  = None
        self._currentSignal = None
        
    def parseDbc(self,file):
        with open(file,'r') as f:
            for line in f:
                self.parseLine(line)
    def parseLine(self,line):
        for key,func in self.keyWords.items():
            if line.startswith(key):
                line = line.strip()
                func(line)
        
    def versionHdl(self,line):
        self.patten = 'VERSION\s+"(?P<version>\S+)"'
        reg = re.search(self.patten ,line)
        if reg:
            self._canNetwork.Version = reg.group('version')
        else:
            raise AttributeError('no version defined')
        
    def nodeHdl(self,line):
        self.patten = 'BU_\s*:\s*(?P<nodes>.+)\s*'
        reg = re.search(self.patten ,line)
        reg = re.sub('\s+', ' ', reg.group('nodes')).strip()
        if reg:
            for nodeName in reg.split(' '):
                self._canNetwork.appendNodes(nodeName,dbcCoreModel.CoreModel.CanNode(nodeName))
        else:
            raise AttributeError('no node defined')

    def msgHdl(self,line):
        self.patten = 'BO_\s+(?P<msgId>\d+)\s+(?P<msgName>\S+)\s*:\s*(?P<length>\d+)\s+(?P<msgSender>\S+)'
        reg = re.search(self.patten, line)
        
        try:
            self._currentMsgSender = self._canNetwork._nodes[reg.group('msgSender')]
        except KeyError:
            print('the msg sender {0} is not in the list of ecu nodes'.format(reg.group('msgSender')))
            self._currentMsgSender = dbcCoreModel.CoreModel.CanNode(reg.group('msgSender'))
            self._canNetwork.appendNodes(self._currentMsgSender.NodeName,self._currentMsgSender)
            
        #create a message object    
        self._currentMsg = dbcCoreModel.CoreModel.CanMsg(reg.group('msgId'),reg.group('msgName'),reg.group('length'),msgSender = self._currentMsgSender)
        #add this message to parent node's tx message
        self._canNetwork.Nodes[self._currentMsg.MsgSender.NodeName].appendTxMsg(self._currentMsg.MsgName,self._currentMsg)

              
    def signalHdl(self,line):
        self.pattern  = 'SG_\s+(?P<name>\S+)\s*(?P<isMultiplexer>M)?(?P<multiplexerId>m\d+)?\s*:\s*'
        self.pattern += '(?P<startBit>\d+)\|(?P<length>\d+)\@(?P<littleEndian>[0|1])(?P<signed>[\+|\-])\s*'
        self.pattern += '\(\s*(?P<factor>\S+)\s*,\s*(?P<offset>\S+)\s*\)\s*'
        self.pattern += '\[\s*(?P<valueMin>\S+)\s*\|\s*(?P<valueMax>\S+)\s*\]\s*"?(?P<unit>[^"]*)?"?\s+(?P<receivers>.+)'
        reg = re.search(self.pattern, line)
        #create a signal object
        self._currentSignal= dbcCoreModel.CoreModel.CANSignal(reg.group('name'),reg.group('startBit'),reg.group('length'),reg.group('littleEndian'),reg.group('signed'),
                                                 reg.group('factor'),reg.group('offset'),reg.group('valueMin'),reg.group('valueMax'),reg.group('unit'),
                                                 reg.group('isMultiplexer'),reg.group('multiplexerId'),msgCarrier = self._currentMsg)
        #add this signal to parent msg
        self._currentMsg.appendSignal(self._currentSignal.SignalName, self._currentSignal)
        
if __name__ == "__main__":
    import sys
    myParser = dbcParser()
    myParser.parseDbc(sys.argv[1])
    for nodeName,node in myParser._canNetwork.Nodes.items():
        print("{0}".format(nodeName))
        for msgName,msg in node.NodeTxMsgs.items():
            print("        {0}".format(msgName))
            for signalName,signal in msg.MsgSignals.items():
                print("                {0},start-{1},len-{2},endian-{3},sign-{4},factor-{5},offset-{6},Min-{7},Max-{8},unit-{9}"
                      .format(signalName,signal.SignalStartBit,signal.SignalLength,signal.SignalLittleEndian,signal.SignalSigned,signal.SignalFactor,signal.SignalOffset,signal.SignalMinValue,signal.SignalMaxValue,signal.SignalUnit))
    print('dbc parsing succeed')
